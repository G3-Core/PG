# Resumo da Aula 01 ‚Äì Processamento Gr√°fico (PG) ‚Äì 2025

## Informa√ß√µes Gerais

A disciplina **Processamento Gr√°fico** √© oferecida no curso de Ci√™ncia da Computa√ß√£o pelo Campus Sorocaba da Universidade Federal de S√£o Carlos (UFSCar). Os respons√°veis pela disciplina s√£o os professores **Siovani** e **M√°rio**. As aulas ocorrem semanalmente e t√™m como objetivo introduzir conceitos fundamentais de computa√ß√£o gr√°fica e processamento de imagens.

O plano de ensino e outras informa√ß√µes podem ser acessadas atrav√©s do site oficial da disciplina:  
üëâ [https://sistemas.ufscar.br/siga/](https://sistemas.ufscar.br/siga/)

---

## Ementa da Disciplina

A disciplina abrange os seguintes t√≥picos:

1. **Introdu√ß√£o:** Hist√≥ria, softwares, hardwares e pesquisas relacionadas ao processamento gr√°fico.
2. **Fundamenta√ß√£o:** Conceitos sobre imagens, modelagem geom√©trica e sistemas de cores.
3. **Processamento de Imagens:** Filtros espaciais, realce de imagens, segmenta√ß√£o, representa√ß√£o e descri√ß√£o de objetos em imagens.
4. **Sistemas de Coordenadas e Transforma√ß√µes:** Inclui transforma√ß√µes lineares, afins, proje√ß√µes e simula√ß√£o de c√¢mera virtual.
5. **S√≠ntese de Imagens:** Pipeline gr√°fico, rasteriza√ß√£o, raytracing e t√©cnicas de ilumina√ß√£o e tonaliza√ß√£o.

Esses temas formam a base te√≥rica e pr√°tica para compreender e desenvolver aplica√ß√µes gr√°ficas modernas.

---

## Requisitos da Disciplina

Para cursar a disciplina, o aluno deve cumprir os pr√©-requisitos estabelecidos pelo projeto pedag√≥gico vigente:

> **(524204 OU (345083 OU (342190 OU 343420 OU 349623 OU 342017) E (343145 OU 341673)) OU 524000 OU 343510 OU 524190) E (1001109 OU 343161 OU 481440)**

Esses c√≥digos correspondem a disciplinas anteriores ou correlatas que devem ter sido cursadas ou estar sendo cursadas simultaneamente.

---

## Objetivos Gerais

Os principais objetivos da disciplina s√£o:

- Apresentar os conceitos introdut√≥rios √† √°rea de processamento gr√°fico em computa√ß√£o.
- Ensinar os m√©todos, t√©cnicas e aplica√ß√µes mais relevantes de **computa√ß√£o gr√°fica (CG)** e **processamento de imagens (PI)**.
- Desenvolver habilidades pr√°ticas nos alunos para a implementa√ß√£o de aplica√ß√µes gr√°ficas.
- Motivar os discentes a seguir estudos avan√ßados nas √°reas de CG e PI em disciplinas espec√≠ficas futuras.

---

## Estrat√©gias de Ensino

A metodologia adotada na disciplina √© centrada em:

- **Aulas te√≥rico-pr√°ticas** com resolu√ß√£o de problemas e programa√ß√£o estruturada.
- **Atividades pr√°ticas** envolvendo a aplica√ß√£o de t√©cnicas de processamento gr√°fico.
- **Aprendizagem baseada em problemas**, incentivando a experimenta√ß√£o e valida√ß√£o computacional das solu√ß√µes propostas.

Durante os encontros presenciais, ser√£o realizados esclarecimentos de d√∫vidas sobre conte√∫dos disponibilizados previamente de forma ass√≠ncrona.

### Recursos Utilizados:
- V√≠deos explicativos dos conte√∫dos principais.
- Material complementar para leitura e estudo.
- Exerc√≠cios te√≥ricos e de implementa√ß√£o.

---

## Atividades Esperadas dos Alunos

Os alunos dever√£o:

- Participar regularmente das aulas presenciais.
- Assistir aos v√≠deos disponibilizados de forma ass√≠ncrona.
- Resolver exerc√≠cios te√≥ricos e pr√°ticos.
- Elaborar e entregar os trabalhos propostos.
- Estudar os conte√∫dos apresentados e discutidos em sala.
- Esclarecer d√∫vidas durante os encontros presenciais.
- Entregar todas as atividades pontualmente.
- Ler e praticar os textos recomendados.
- Agir de maneira pr√≥-ativa nas atividades individuais e grupais.

---

## Recursos Necess√°rios

Para acompanhar as atividades da disciplina, ser√° necess√°rio:

- Projetor multim√≠dia e acesso a computadores.
- Instala√ß√£o do **Octave 4.2.2** (ambiente de programa√ß√£o num√©rica).
- Um navegador compat√≠vel com **WebGL**.
- Conex√£o com internet de boa qualidade.
- Para algumas atividades, pode ser necess√°rio um monitor de v√≠deo de alta resolu√ß√£o.

---

## Avalia√ß√£o

As avalia√ß√µes ser√£o **presenciais**, com exce√ß√£o dos projetos parciais, que ser√£o desenvolvidos de forma **ass√≠ncrona em grupo**. A composi√ß√£o da Nota Final (NF) ser√°:

| Componente           | Peso |
|----------------------|------|
| Prova 1 (P1)         | 25%  |
| Prova 2 (P2)         | 25%  |
| Projeto Parcial 1 (PP1) | 25%  |
| Projeto Parcial 2 (PP2) | 25%  |

### F√≥rmula da Nota Final:

$$
NF = 0.25 \times P1 + 0.25 \times P2 + 0.25 \times PP1 + 0.25 \times PP2
$$

#### Crit√©rios de aprova√ß√£o:
- **Nota Final ‚â• 6,0**
- **Frequ√™ncia ‚â• 75%**

---

## Regras Importantes

- **Trabalhos id√™nticos entre grupos** caracterizam **cola acad√™mica** e resultam em **NF = 0** para todos os envolvidos.
- **Uso n√£o autorizado de c√≥digo da internet** tamb√©m √© considerado cola e implica NF = 0.
- Cada prova e projeto parcial tem peso igual na nota final.
- Entregas devem ser feitas via **Google Sala de Aula**, usando o c√≥digo fornecido: **udkovrd7**.

---

## Calend√°rio Acad√™mico (Datas Importantes)

| Evento             | Data                |
|--------------------|---------------------|
| Prova 1 (P1)       | 24 de abril de 2025 |
| Projeto Parcial 1 (PP1) | 22 de maio de 2025 |
| Prova 2 (P2)       | 03 de julho de 2025 |
| Projeto Parcial 2 (PP2) | 24 de julho de 2025 |
| T√©rmino do per√≠odo letivo | 26 de julho de 2025 |

---

## Prova Complementar (PC)

Alunos que obtiverem **Nota Final entre 5,0 e 5,9** e **frequ√™ncia ‚â• 75%** poder√£o realizar uma √∫nica **Prova Complementar (PC)**, cujo conte√∫do abranger√° toda a mat√©ria.

A nova m√©dia final (NMF) ser√° calculada da seguinte forma:

- Se **PC ‚â• 6**, ent√£o **NMF = 6**.
- Se **PC < 6**, ent√£o **NMF = max(NF, PC)**.

O aluno ser√° considerado **aprovado se NMF ‚â• 6**.

A Prova Complementar ser√° aplicada **at√© 35 dias ap√≥s o in√≠cio do pr√≥ximo semestre letivo**.

---

## Frequ√™ncia e Regime de Avalia√ß√£o

De acordo com o **Regimento Geral dos Cursos de Gradua√ß√£o da UFSCar**, o aluno tem direito a um limite m√°ximo de faltas. A aus√™ncia em avalia√ß√µes presenciais s√≥ ser√° justificada mediante comprova√ß√£o documental, conforme normas institucionais.

Revis√µes de provas ser√£o realizadas dentro do prazo estipulado e sob orienta√ß√£o do professor respons√°vel.

---

## Bibliografia Recomendada

### **Bibliografia B√°sica**

1. **Gortler, S. J.** ‚Äì *Foundations of 3D Computer Graphics*, MIT Press, 2012.
2. **Gomes, J.; Velho, L.** ‚Äì *Fundamentos da Computa√ß√£o Gr√°fica*, IMPA, 2003.
3. **Gonzalez, R.; Woods, R.** ‚Äì *Processamento Digital de Imagens*, Edgar Bl√ºcher Ltda., 2000.
4. **Jain, A.** ‚Äì *Fundamentals of Digital Image Processing*, Prentice-Hall, 1989.

### **Bibliografia Complementar**

1. **Sonka, M.; Hlavac, V.; Boyle, R.** ‚Äì *Image Processing, Analysis and Machine Vision*, PWS Publishing, 1999.
2. **Baxes, G.** ‚Äì *Digital Image Processing: Principles and Applications*, John Wiley & Sons, 1994.
3. **Angel, D.; Shreiner, D.** ‚Äì *Interactive Computer Graphics*, 6¬™ edi√ß√£o, 2012.
4. **Hearn, D.; Baker, M.** ‚Äì *Computer Graphics with OpenGL*, 3¬™ edi√ß√£o, 2004.
5. **Velho, L.; Gomes, J. M.** ‚Äì *Sistemas Gr√°ficos 3D*, IMPA, 2007.
6. **Cohen, M.** ‚Äì *OpenGL: Uma Abordagem Pr√°tica e Objetiva*, 2006.
7. **Azevedo, E.; Conci, A.** ‚Äì *Computa√ß√£o Gr√°fica: Teoria e Pr√°tica*, 2003.

### Plataforma Virtual

Parte da bibliografia est√° dispon√≠vel digitalmente na plataforma **bvirtual**:
üëâ [https://plataforma.bvirtual.com.br/](https://plataforma.bvirtual.com.br/)

---

## Considera√ß√µes Finais

A disciplina de **Processamento Gr√°fico** √© fundamental para o desenvolvimento de compet√™ncias em √°reas como **computa√ß√£o gr√°fica, vis√£o computacional, processamento de imagens e s√≠ntese de imagens**. Al√©m do conte√∫do te√≥rico, o aluno ser√° desafiado a aplicar esses conhecimentos por meio de **implementa√ß√µes pr√°ticas e projetos colaborativos**, preparando-o para atuar em contextos tecnol√≥gicos avan√ßados.

√â essencial que o aluno mantenha **disciplina, organiza√ß√£o e √©tica acad√™mica**, especialmente no desenvolvimento de projetos e entrega de atividades. O uso correto de recursos e ferramentas, bem como a participa√ß√£o ativa nas aulas e atividades, s√£o fatores determinantes para o sucesso na disciplina.

---

# **Resumo da Aula 02 ‚Äì Processamento Gr√°fico (2025-1)**  

## **1. Hist√≥rico do Processamento Gr√°fico**

O Processamento Gr√°fico √© uma √°rea multidisciplinar que se desenvolveu fortemente com o avan√ßo da capacidade computacional. Ele envolve t√©cnicas relacionadas √† gera√ß√£o, manipula√ß√£o, an√°lise e interpreta√ß√£o de imagens e informa√ß√µes visuais.

### **Evolu√ß√£o Inicial**
- Os primeiros registros de imagens geradas por computador datam de 1950, criados por **Ben Laposky** usando um oscilosc√≥pio anal√≥gico.
- Em 1960, o termo **‚ÄúComputa√ß√£o Gr√°fica‚Äù (CG)** foi introduzido por **William Fetter**, durante seu trabalho na Boeing, para descrever o uso de imagens tridimensionais na simula√ß√£o de posi√ß√µes humanas em cabines de avi√µes.
- Um marco importante foi a tese de doutorado de **Ivan Sutherland (1963)**, que desenvolveu o sistema **Sketchpad**, pioneiro na cria√ß√£o e edi√ß√£o interativa de desenhos t√©cnicos no computador.
- O Sketchpad introduziu os primeiros algoritmos de transforma√ß√µes geom√©tricas e recorte de objetos gr√°ficos.

### **Avan√ßos Posteriores**
- A Computa√ß√£o Gr√°fica tornou-se essencial como interface entre o homem e o computador, evoluindo de interfaces textuais para ambientes 3D interativos.
- Revolucionou setores como cinema, jogos, visualiza√ß√£o cient√≠fica, arquitetura, engenharia e simula√ß√£o de fen√¥menos f√≠sicos.

## **2. √Åreas Relacionadas ao Processamento Gr√°fico**

A disciplina de Processamento Gr√°fico abrange diversas √°reas que lidam com informa√ß√£o visual. Essas √°reas diferem principalmente quanto √† natureza das entradas e sa√≠das do processamento:

### **2.1. Computa√ß√£o Gr√°fica (CG)**
- **Entrada:** Dados (como coordenadas, modelos matem√°ticos).
- **Sa√≠da:** Imagens ou representa√ß√µes visuais.
- Objetivo: Criar, manipular e exibir imagens sint√©ticas.
- Aplica√ß√µes: Jogos, filmes, projetos CAD, realidade virtual e aumentada.

### **2.2. Vis√£o Computacional (VC)**
- **Entrada:** Imagens reais (fotografias, v√≠deos).
- **Sa√≠da:** Informa√ß√µes sobre o mundo real (como posi√ß√£o, forma, movimento).
- Objetivo: Extrair conhecimento a partir de imagens.
- Aplica√ß√µes: Rob√≥tica, reconhecimento facial, ve√≠culos aut√¥nomos, sistemas de seguran√ßa.

### **2.3. Processamento de Imagens (PI)**
- **Entrada:** Imagens.
- **Sa√≠da:** Imagens modificadas ou melhoradas.
- Objetivo: Transformar ou melhorar a qualidade visual ou informativa da imagem.
- Aplica√ß√µes: Medicina (tomografia), sat√©lites, fotografia digital, compress√£o de imagens.

### **2.4. Processamento de Dados (PD)**
- **Entrada e Sa√≠da:** Dados n√£o visuais.
- Trabalha com informa√ß√µes que n√£o s√£o necessariamente ligadas √† vis√£o ou imagens.

### **Rela√ß√£o entre as √°reas**
| √Årea | Entrada | Sa√≠da |
|------|---------|-------|
| **Computa√ß√£o Gr√°fica (CG)** | Dados | Imagens |
| **Vis√£o Computacional (VC)** | Imagens | Dados |
| **Processamento de Imagens (PI)** | Imagens | Imagens |
| **Processamento de Dados (PD)** | Dados | Dados |

## **3. Processamento de Imagens ‚Äì Hist√≥rico e Aplica√ß√µes**

### **Hist√≥rico**
- As primeiras aplica√ß√µes pr√°ticas surgiram em 1921, com transmiss√£o de imagens em n√≠veis de cinza atrav√©s de cabos submarinos entre Londres e Nova York.
- Em 1929, o n√∫mero de n√≠veis de cinza aumentou de 5 para 15, melhorando a qualidade das imagens transmitidas.
- O grande impulso ocorreu durante a era espacial americana (anos 1960), quando foram utilizadas t√©cnicas de PI para melhorar imagens capturadas por sondas como a **Ranger 7**, que enviou as primeiras fotos da Lua em 1964.
- Na medicina, o desenvolvimento da **Tomografia Computadorizada**, por **Godfrey Hounsfield** e **Allan Cormack**, foi um marco importante. Ambos receberam o Pr√™mio Nobel de Medicina em 1979.

### **Aplica√ß√µes Atuais**
- **Medicina:** Diagn√≥stico por imagem, radiologia, ultrassonografia.
- **Biologia:** An√°lise de microscopia, mapeamento gen√©tico.
- **Geoprocessamento:** Sensoriamento remoto, SIGs (Sistemas de Informa√ß√µes Geogr√°ficas).
- **Rob√≥tica:** Navega√ß√£o, detec√ß√£o de obst√°culos.
- **Comunica√ß√µes:** Codifica√ß√£o e compress√£o de v√≠deo.
- **Meteorologia:** Previs√£o do tempo, an√°lise de sat√©lites.
- **Automa√ß√£o Industrial:** Controle de qualidade, inspe√ß√£o automatizada.
- **Seguran√ßa:** Reconhecimento facial, vigil√¢ncia.

## **4. Sistema Visual Humano**

A compreens√£o do sistema visual humano √© fundamental para o estudo do Processamento Gr√°fico, pois influencia diretamente na forma como percebemos e interpretamos as imagens.

### **Componentes B√°sicos do Olho Humano**
- A retina cont√©m dois tipos principais de receptores:
  - **Cones:** Respons√°veis pela vis√£o colorida e de alta defini√ß√£o, localizados principalmente na f√≥vea (regi√£o central da retina). Existem cerca de 6 a 7 milh√µes em cada olho.
  - **Bastonetes:** Sens√≠veis √† luz fraca, respons√°veis pela vis√£o noturna e perif√©rica. Cada olho possui entre 75 e 150 milh√µes de bastonetes.

### **Curiosidades sobre a Vis√£o Humana**
- Com boa ilumina√ß√£o, conseguimos distinguir linhas separadas por apenas **0,01 graus**.
- O campo visual humano √© de aproximadamente **120¬∞ na horizontal** e **60¬∞ na vertical**.
- Mulheres tendem a ter mais cones, o que lhes confere maior sensibilidade √†s cores.
- Homens possuem mais bastonetes, o que resulta em melhor vis√£o noturna.
- Cerca de **8% dos homens** e **0,4% das mulheres** s√£o dalt√¥nicos.

### **Interpreta√ß√£o Visual e Erros de Percep√ß√£o**
- O c√©rebro humano utiliza mecanismos como **filtragem de informa√ß√µes** e **detec√ß√£o de limiar** para otimizar o processamento visual.
- A interpreta√ß√£o de imagens envolve tanto o hemisf√©rio esquerdo (l√≥gico) quanto o direito (criativo), o que pode levar a **erros de interpreta√ß√£o** ou **dupla percep√ß√£o**.
- Exemplos famosos incluem figuras amb√≠guas como ‚ÄúA jovem e a idosa‚Äù, onde a mesma imagem pode ser interpretada de formas diferentes.

### **Ilus√µes √ìticas**
- Ilus√µes √≥ticas demonstram como o c√©rebro preenche lacunas e interpreta padr√µes mesmo na aus√™ncia de dados completos.
- Exemplo cl√°ssico: **Ilus√£o de Kanizsa**, onde formas inexistentes parecem estar presentes devido ao contexto visual.
- Estudos recentes tamb√©m exploram como **intelig√™ncias artificiais** podem ser enganadas por "ilus√µes", chamadas de **adversarial examples**, onde pequenas altera√ß√µes impercept√≠veis mudam completamente a interpreta√ß√£o feita por um modelo.

## **5. Conclus√£o**

A disciplina de Processamento Gr√°fico abrange um amplo espectro de conhecimentos, desde a hist√≥ria das tecnologias visuais at√© as bases biol√≥gicas da percep√ß√£o humana. Entender as diferen√ßas entre √°reas como Computa√ß√£o Gr√°fica, Vis√£o Computacional e Processamento de Imagens √© essencial para aplicar corretamente as ferramentas e t√©cnicas em diversos contextos. Al√©m disso, compreender o funcionamento do sistema visual humano permite desenvolver solu√ß√µes mais eficazes e intuitivas no tratamento de imagens e na intera√ß√£o humano-computador.

---

# Resumo da Aula 03 ‚Äì Processamento Gr√°fico  

---

## 1. Introdu√ß√£o ao Sistema de Vis√£o Humano

O sistema de vis√£o humano √© extremamente avan√ßado e eficiente no processamento de informa√ß√µes visuais. Alguns pontos importantes:

- O c√©rebro humano consegue processar e interpretar uma grande quantidade de informa√ß√µes visuais em cerca de **150 milissegundos**, o que permite o reconhecimento r√°pido de objetos e cenas.
- O c√©rebro age como uma verdadeira ‚Äúm√°quina de reconhecimento‚Äù, capaz de representar informa√ß√µes em diferentes n√≠veis de abstra√ß√£o.
- A base de conhecimento utilizada pelo c√©rebro varia de pessoa para pessoa, dependendo das experi√™ncias individuais e do aprendizado acumulado.
- Pesquisas buscam imitar esse processo para desenvolver sistemas artificiais capazes de reconhecer padr√µes e objetos visualmente.

---

## 2. Sistema de Vis√£o Artificial (SVA)

### Defini√ß√£o:
Um Sistema de Vis√£o Artificial √© um sistema computadorizado capaz de **adquirir, processar e interpretar imagens** correspondentes a cenas reais, com o objetivo de extrair informa√ß√µes √∫teis delas.

---

## 3. Vantagens dos Sistemas de Vis√£o Artificial

Os SVAs contam com diversos fatores tecnol√≥gicos favor√°veis:

- **Avan√ßos em dispositivos de armazenamento em massa**: permitem guardar grandes volumes de dados visuais.
- **Desenvolvimento de CPUs e GPUs mais r√°pidas**: aumenta a capacidade de processamento de imagens em alta velocidade.
- **Arquiteturas computacionais modernas e paralelismo**: possibilitam o uso de algoritmos complexos de forma eficiente.

Esses avan√ßos tecnol√≥gicos tornaram os SVAs ferramentas poderosas para an√°lise visual automatizada.

---

## 4. Desafios dos Sistemas de Vis√£o Artificial

Apesar dos avan√ßos, os SVAs enfrentam v√°rios desafios t√©cnicos e pr√°ticos:

- **Diferentes condi√ß√µes de luminosidade e contraste**: podem alterar significativamente a apar√™ncia de objetos nas imagens.
- **Posicionamento relativo dos objetos na cena (profundidade)**: afeta a interpreta√ß√£o espacial e a capacidade de identifica√ß√£o precisa.
- **Mudan√ßa de perspectiva e escala**: os objetos devem ser reconhecidos mesmo quando aparecem em diferentes tamanhos ou √¢ngulos.

Esses desafios exigem algoritmos robustos e adapta√ß√µes constantes para melhorar a precis√£o do sistema.

---

## 5. Aplica√ß√µes de Sistemas de Vis√£o Artificial

Os SVAs possuem uma ampla gama de aplica√ß√µes em diversos setores, incluindo:

- **Ind√∫stria**: automa√ß√£o de linhas de produ√ß√£o, inspe√ß√£o de qualidade e detec√ß√£o de falhas.
- **Transporte inteligente**: reconhecimento de placas de ve√≠culos, controle de tr√°fego e assist√™ncia √† navega√ß√£o.
- **Agricultura**: monitoramento de planta√ß√µes, detec√ß√£o de pragas e automa√ß√£o de colheitas.
- **Medicina**: diagn√≥stico por imagem, cirurgias assistidas e an√°lise de exames.
- **Seguran√ßa**: vigil√¢ncia, reconhecimento facial e detec√ß√£o de movimentos suspeitos.
- **Log√≠stica**: leitura autom√°tica de c√≥digos de barras, identifica√ß√£o de pacotes e triagem autom√°tica.

Exemplos espec√≠ficos mencionados na aula incluem drones e sistemas de triagem postal.

---

## 6. Estrutura B√°sica de um Sistema de Vis√£o Artificial

A arquitetura geral de um SVA pode ser dividida em v√°rias etapas fundamentais:

### 1. **Dom√≠nio do Problema**
   - Define-se qual √© o problema a ser resolvido e quais s√£o os resultados esperados.
   - Exemplo: ler CEPs em envelopes; resultado esperado: sequ√™ncia de d√≠gitos do CEP.

### 2. **Aquisi√ß√£o da Imagem**
   - Envolve a captura da imagem usando sensores √≥pticos e convers√£o para formato digital.
   - Fatores importantes:
     - Tipo de lente utilizada;
     - Condi√ß√µes de ilumina√ß√£o;
     - Velocidade e resolu√ß√£o de aquisi√ß√£o.

### 3. **Pr√©-processamento**
   - Objetivo: melhorar a qualidade da imagem antes das etapas posteriores.
   - Tarefas comuns:
     - Redu√ß√£o de ru√≠do;
     - Ajuste de contraste e brilho;
     - Corre√ß√£o de caracteres interrompidos ou conectados incorretamente.
   - Trabalha diretamente nos valores dos pixels, sem interpreta√ß√£o sem√¢ntica.

### 4. **Segmenta√ß√£o**
   - Consiste em dividir a imagem em partes ou objetos de interesse.
   - No exemplo do CEP, envolve:
     - Isolar a regi√£o onde o CEP est√° localizado;
     - Separar cada d√≠gito individualmente para an√°lise.

### 5. **Extra√ß√£o de Caracter√≠sticas**
   - Extrai descritores que caracterizam os objetos segmentados (por exemplo, formas, bordas, texturas).
   - Os descritores s√£o convertidos em estruturas de dados compat√≠veis com algoritmos de reconhecimento.

### 6. **Reconhecimento e Interpreta√ß√£o**
   - **Reconhecimento:** atribui√ß√£o de r√≥tulos aos objetos com base em suas caracter√≠sticas extra√≠das.
   - **Interpreta√ß√£o:** dar sentido ao conjunto de objetos reconhecidos.
     - Exemplo: verificar se o CEP lido existe em uma base de dados v√°lida.

### 7. **Base de Conhecimento**
   - Armazena informa√ß√µes essenciais para todas as etapas do sistema.
   - Permite realimenta√ß√£o entre as etapas, garantindo corre√ß√£o e otimiza√ß√£o cont√≠nuas.
   - Exemplo: caso o reconhecimento retorne um n√∫mero incorreto de d√≠gitos, a base de conhecimento pode acionar novamente a etapa de segmenta√ß√£o para ajuste.

---

## 7. Exemplo Pr√°tico: Leitura Autom√°tica de CEP em Envelopes

Esse exemplo foi utilizado durante a aula para ilustrar o funcionamento de um SVA aplicado √† log√≠stica postal:

- **Objetivo:** Ler o CEP em envelopes automaticamente.
- **Etapas:**
  1. Aquisi√ß√£o da imagem do envelope com c√¢mera ou scanner.
  2. Pr√©-processamento para limpar a imagem e melhorar o contraste.
  3. Segmenta√ß√£o para isolar a regi√£o do CEP.
  4. Extra√ß√£o de caracter√≠sticas dos d√≠gitos.
  5. Reconhecimento dos n√∫meros usando t√©cnicas de machine learning ou redes neurais.
  6. Interpreta√ß√£o final: verifica√ß√£o do CEP em uma base de dados oficial.
  7. Uso de uma base de conhecimento para validar e corrigir erros durante o processo.

---

## 8. Import√¢ncia da Realimenta√ß√£o e da Base de Conhecimento

A **realimenta√ß√£o** entre as etapas do sistema √© crucial para aprimorar os resultados e corrigir falhas. Por exemplo:

- Se o reconhecimento detectar um n√∫mero inv√°lido de d√≠gitos, o sistema pode solicitar uma nova segmenta√ß√£o da imagem.
- A **base de conhecimento** atua como um guia constante, permitindo decis√µes inteligentes e ajustes autom√°ticos ao longo do processo.

---

## 9. Considera√ß√µes Finais

Os Sistemas de Vis√£o Artificial s√£o ferramentas poderosas e vers√°teis, capazes de revolucionar diversos setores da sociedade. Seu desenvolvimento depende n√£o apenas de avan√ßos tecnol√≥gicos, mas tamb√©m de algoritmos inteligentes e bases de conhecimento bem estruturadas. Combinando hardware adequado e software eficiente, √© poss√≠vel construir sistemas capazes de enxergar, interpretar e agir com alto grau de autonomia.

---

# Resumo da Aula 04 ‚Äì Processamento Gr√°fico (PG) ‚Äì 2025  
## Tema: Fundamentos de Imagens Digitais

### Introdu√ß√£o

Essa aula introduz os conceitos fundamentais sobre **imagens digitais**, abordando desde sua forma√ß√£o f√≠sica at√© as propriedades matem√°ticas e computacionais relacionadas √† **resolu√ß√£o espacial e em amplitude**, al√©m de conceitos como adjac√™ncia, conectividade, vizinhan√ßa e defini√ß√µes de borda e fronteira em imagens.

---

## 1. Forma√ß√£o F√≠sica da Imagem

As imagens s√£o formadas pela luz refletida pelos objetos. Essa reflex√£o depende de dois fatores principais:

- **Ilumin√¢ncia (i(x,y))**: quantidade de luz incidente sobre o objeto.
- **Reflet√¢ncia (r(x,y))**: propor√ß√£o da luz refletida pelo objeto naquele ponto.

Portanto, a intensidade luminosa observada em uma imagem pode ser descrita por uma fun√ß√£o cont√≠nua:

$$
f(x, y) = i(x, y) \cdot r(x, y)
$$

Onde:
- $ 0 < i(x, y) < \infty $: ilumin√¢ncia varia conforme fonte de luz.
- $ 0 \leq r(x, y) \leq 1 $: reflet√¢ncia depende das caracter√≠sticas f√≠sicas dos objetos.

Exemplos:
- **Ilumin√¢ncia t√≠pica (em lux):**
  - Dia ensolarado: 900
  - Ilumina√ß√£o m√©dia de escrit√≥rio: 10
  - Noite de lua cheia: 0,001
- **Reflet√¢ncia t√≠pica:**
  - Neve: 0,93
  - Veludo preto: 0,01

---

## 2. Defini√ß√£o de Imagem Digital

Uma **imagem digital** √© uma representa√ß√£o discreta de uma imagem cont√≠nua. Ela √© obtida atrav√©s de dois processos principais:

- **Amostragem**: discretiza√ß√£o espacial da imagem (transforma a imagem cont√≠nua em pixels).
- **Quantiza√ß√£o**: discretiza√ß√£o em amplitude (converte os n√≠veis de cinza em valores inteiros).

Uma imagem digital pode ser representada por uma matriz **f(x, y)**, onde:
- $ x $ e $ y $: coordenadas espaciais inteiras.
- $ f(x, y) $: valor do n√≠vel de cinza no pixel $(x, y)$.
- $ W $: n√∫mero m√°ximo de n√≠veis de cinza (geralmente $ W = 2^n $, onde $ n $ √© o n√∫mero de bits por pixel).

---

## 3. Resolu√ß√£o Espacial e em Amplitude

### 3.1. Resolu√ß√£o Espacial

Refere-se √† capacidade de distinguir detalhes finos em uma imagem. √â determinada pelo n√∫mero de pixels na imagem (dimens√µes M x N). Exemplos:

- Sat√©lites LANDSAT: resolu√ß√£o espacial de 5 m a 80 m.
- Tomografia m√©dica: resolu√ß√£o de 1 mm.
- Documentos digitalizados: resolu√ß√£o expressa em pontos por polegada (dpi).

### 3.2. Resolu√ß√£o em Amplitude (N√≠veis de Cinza)

Determina a quantidade de tons de cinza dispon√≠veis na imagem. Geralmente √© definida por $ L = 2^n $, onde $ n $ √© o n√∫mero de bits por pixel.

- 1 bit: 2 n√≠veis (bin√°rio ‚Äì preto e branco)
- 8 bits: 256 n√≠veis de cinza (comum em imagens padr√£o)
- 16 bits: 65.536 n√≠veis (imagens m√©dicas ou cient√≠ficas)

Quanto maior o n√∫mero de n√≠veis de cinza, mais suave √© a transi√ß√£o entre tons.

---

## 4. Efeitos da Redu√ß√£o de N√≠veis de Cinza

A redu√ß√£o de n√≠veis de cinza pode levar ao aparecimento de **falsos contornos (false contouring)**, especialmente quando usamos poucos n√≠veis (ex.: 4 a 32 n√≠veis). Isso cria efeitos visuais indesej√°veis, semelhantes a bandas ou faixas na imagem.

Exemplo pr√°tico:
- Em imagens com 32 n√≠veis de cinza, j√° se percebem imperfei√ß√µes.
- Em imagens com 2 n√≠veis (bin√°rias), perde-se totalmente a percep√ß√£o de gradiente.

---

## 5. Propriedades Matem√°ticas e Computacionais de Imagens Digitais

### 5.1. Adjac√™ncia

Dois pixels s√£o considerados adjacentes se estiverem pr√≥ximos espacialmente. Existem tr√™s tipos principais:

- **4-adjacentes**: compartilham uma borda (norte, sul, leste, oeste).
- **8-adjacentes**: compartilham uma borda ou um v√©rtice (vizinhos diagonais tamb√©m inclu√≠dos).
- **D-adjacentes**: vizinhos diagonais apenas.

### 5.2. Vizinhan√ßa

Define quais pixels est√£o pr√≥ximos a um determinado pixel central:

- **N4(p)**: vizinhan√ßa de 4 pixels (adjacentes horizontais e verticais).
- **ND(p)**: vizinhan√ßa diagonal.
- **N8(p)**: vizinhan√ßa completa (inclui todos os 8 pixels ao redor do central).

### 5.3. Conectividade

Relaciona-se com a adjac√™ncia e define caminhos entre pixels:

- **Conectividade-4**: pixels conectados por bordas.
- **Conectividade-8**: pixels conectados por bordas ou v√©rtices.
- **Conectividade-m (mista)**: evita dupla conex√£o entre pixels.

Usa-se um conjunto $ V = \{G_1, G_2, ..., G_k\} $ de n√≠veis de cinza para determinar quais pixels s√£o considerados conectados.

### 5.4. Encadeamento

√â a sequ√™ncia de pixels conectados dentro de uma regi√£o. Pode ser:

- **4-encadeamento**: seguindo somente pixels adjacentes por borda.
- **8-encadeamento**: incluindo pixels adjacentes por v√©rtice.

Permite identificar regi√µes e contornos em imagens.

---

## 6. Borda vs. Fronteira

- **Borda**: conceito local, baseado na mudan√ßa abrupta de intensidade entre pixels adjacentes.
- **Fronteira**: conceito global, representa o caminho fechado que delimita uma regi√£o.

Em imagens bin√°rias, borda e fronteira s√£o equivalentes. Em imagens em n√≠veis de cinza, a borda √© detectada por t√©cnicas de detec√ß√£o de descontinuidade.

---

## 7. Linguagens e Ferramentas Utilizadas

A aula menciona o uso do **Octave** como ferramenta principal para processamento de imagens. Recomenda-se instalar e configurar corretamente a biblioteca **image** no Octave para carregar automaticamente ao iniciar o programa.

### Links √öteis:
- [Manual do Octave](https://bit.ly/2F3Qqed)
- [Programa√ß√£o em Octave](https://bit.ly/2FjveRa)
- [Instala√ß√£o do Octave 4.2.2 (Windows)](https://bit.ly/4cpsBbR)

---

## 8. Considera√ß√µes Finais

Esta aula apresentou os fundamentos essenciais para compreender como as imagens s√£o formadas, armazenadas e manipuladas digitalmente. Os conceitos de **resolu√ß√£o espacial e em amplitude**, **adjac√™ncia**, **conectividade**, **encadeamento** e **borda/fronteira** s√£o cruciais para entender t√©cnicas avan√ßadas de processamento de imagens, como segmenta√ß√£o, realce e an√°lise de formas.

Al√©m disso, foi refor√ßada a import√¢ncia do uso de ferramentas como o Octave para aplicar teorias na pr√°tica, preparando o aluno para implementar algoritmos b√°sicos de processamento gr√°fico.

---

# **Resumo da Aula 05 ‚Äì Processamento Gr√°fico (2025-1)**  

---

## **1. N√≠veis de Cinza e Representa√ß√£o Visual**

### **1.1. Mostrando Todos os N√≠veis de Cinza**
- √â poss√≠vel gerar uma imagem que exibe todos os n√≠veis de cinza entre preto e branco usando linguagem MATLAB.
- Exemplo:
  ```matlab
  F = (0:15)/16; % cria vetores com 16 n√≠veis de cinza
  G = [F; F; F; F]; % repete a linha 4 vezes para formar uma matriz
  imshow(G); % exibe a imagem
  ```
- Para usar 256 n√≠veis de cinza (mais comuns):
  ```matlab
  F = (0:255)/255;
  G = [F; F; F; F];
  figure, imshow(G);
  ```

### **1.2. Aplica√ß√£o Pr√°tica ‚Äì Arquivo "paleta.m"**
- Este script √© utilizado para criar uma paleta visual cont√≠nua de n√≠veis de cinza.
- Ele permite visualizar como diferentes n√≠veis s√£o distribu√≠dos e percebidos pelo olho humano.
- Essa t√©cnica √© √∫til para entender a faixa din√¢mica de uma imagem e sua qualidade visual.

---

## **2. Histogramas de Imagens**

### **2.1. O que √© um histograma?**
- Um **histograma** √© uma representa√ß√£o gr√°fica que mostra a distribui√ß√£o dos **n√≠veis de cinza** em uma imagem.
- Cada barra representa a **quantidade de pixels** presentes em um determinado n√≠vel de intensidade (de preto a branco).
- √â uma ferramenta essencial para avaliar o **contraste**, **brilho** e **qualidade geral** da imagem.

### **2.2. Tipos de Histogramas**
- **Histograma simples**: mostra o n√∫mero absoluto de pixels por n√≠vel de cinza.
- **Histograma normalizado**: mostra a probabilidade de ocorr√™ncia de cada n√≠vel de cinza na imagem.

#### **F√≥rmula de Normaliza√ß√£o do Histograma**
Para cada n√≠vel de cinza $ r_k $, calcula-se:
$$
P(r_k) = \frac{n_k}{n}
$$
Onde:
- $ n_k $ = n√∫mero de pixels com o n√≠vel de cinza $ r_k $
- $ n $ = total de pixels na imagem
- $ k = 0, 1, ..., L-1 $, onde $ L $ √© o n√∫mero total de n√≠veis de cinza

---

## **3. Interpreta√ß√£o do Histograma**

### **3.1. An√°lise Visual e Estat√≠stica**
- Se o histograma estiver concentrado nos valores baixos (pr√≥ximos ao preto), a imagem ser√° escura.
- Se estiver concentrado nos valores altos (pr√≥ximos ao branco), a imagem ser√° clara.
- Se os pixels estiverem distribu√≠dos uniformemente, a imagem ter√° **alto contraste**.
- Se os pixels estiverem agrupados em poucos n√≠veis, a imagem ter√° **baixo contraste**.

### **3.2. Exemplos de Histogramas**
| Tipo | Caracter√≠sticas | Efeito Visual |
|------|------------------|----------------|
| Histograma escuro | Maioria dos pixels em n√≠veis baixos | Imagem escura |
| Histograma claro | Maioria dos pixels em n√≠veis altos | Imagem clara |
| Histograma de baixo contraste | Pixels concentrados em poucos n√≠veis | Imagem sem defini√ß√£o |
| Histograma de alto contraste | Distribui√ß√£o ampla dos n√≠veis | Imagem bem definida |
| Histograma bimodal | Dois picos claros e escuros | Alto contraste |

> **Nota:** O histograma n√£o fornece informa√ß√µes sobre a localiza√ß√£o dos pixels, apenas sua frequ√™ncia.

---

## **4. Manipula√ß√£o de Histogramas**

### **4.1. Altera√ß√µes Globais de Brilho**
- Consiste em somar ou subtrair uma constante a todos os pixels da imagem:
  - **Soma positiva** ‚Üí aumenta o brilho
  - **Subtra√ß√£o negativa** ‚Üí diminui o brilho
- Algoritmo b√°sico:
  ```
  Para cada pixel (i,j):
    novo_pixel(i,j) = pixel(i,j) + constante_brilho
    se novo_pixel > 255 ‚Üí ajusta para 255 (limite m√°ximo)
    se novo_pixel < 0   ‚Üí ajusta para 0 (limite m√≠nimo)
  ```

### **4.2. Implementa√ß√£o em MATLAB ‚Äì `alt_global.m`**
Exemplo de c√≥digo:
```matlab
A = imread('cacau_escuro.tif');
cte_brilho = 50;
[lin, col] = size(A);
for i = 1:lin
    for j = 1:col
        B(i,j) = A(i,j) + cte_brilho;
        if B(i,j) > 255, B(i,j) = 255; end
        if B(i,j) < 0, B(i,j) = 0; end
    end
end
figure, imshow(B);
figure, imhist(B);
```

---

## **5. Autoescala (Equaliza√ß√£o Linear)**

### **5.1. Conceito**
- A autoescala √© uma transforma√ß√£o linear que expande os n√≠veis de cinza para ocupar todo o intervalo dispon√≠vel (geralmente 0 a 255).
- √â √∫til para melhorar o contraste de imagens escuras ou com pouca varia√ß√£o de tons.

### **5.2. F√≥rmula Matem√°tica**
Dado um pixel com valor original $ f $, o novo valor $ g $ ap√≥s a autoescala √© dado por:
$$
g = 255 \cdot \frac{f - f_{\text{min}}}{f_{\text{max}} - f_{\text{min}}}
$$
Onde:
- $ f_{\text{min}} $ = menor n√≠vel de cinza na imagem
- $ f_{\text{max}} $ = maior n√≠vel de cinza na imagem

### **5.3. Aplica√ß√µes Pr√°ticas**
- Melhora a visibilidade de detalhes em imagens m√©dicas (ex: mamografia, tomografia).
- √ötil em imagens industriais, como soldas e pe√ßas met√°licas, onde pequenas diferen√ßas de brilho podem indicar defeitos.

---

## **6. Exerc√≠cios Recomendados**

### **6.1. Implementa√ß√£o da Fun√ß√£o Autoescala**
- Baseado no script `alt_global.m`, implemente a fun√ß√£o `autoescala.m`.
- Teste-a com as seguintes imagens:
  - `rice.tif`
  - `mamografia.bmp`
  - `batatas.tif`
  - `solda.bmp`
  - `laranjas.bmp`

### **6.2. Objetivo**
- Verificar como a autoescala melhora o contraste e a visibilidade de detalhes em imagens com histogramas mal distribu√≠dos.

---

## **7. Observa√ß√µes Adicionais**

- O processamento de imagens em tons de cinza √© fundamental para an√°lise visual e autom√°tica.
- As t√©cnicas aprendidas nesta aula servem como base para opera√ß√µes mais complexas, como filtragem, segmenta√ß√£o e reconhecimento de padr√µes.
- O uso de histogramas e ajustes de brilho/contraste √© comum em softwares de edi√ß√£o de imagem (Photoshop, GIMP) e em sistemas de vis√£o computacional.

---

## **8. Conclus√£o**

Esta aula apresentou conceitos fundamentais sobre **manipula√ß√£o de n√≠veis de cinza**, **histogramas de imagens**, **altera√ß√µes globais de brilho** e **autoescala linear**. Essas t√©cnicas s√£o essenciais para melhorar a qualidade visual e anal√≠tica das imagens em aplica√ß√µes como medicina, ind√∫stria, rob√≥tica e seguran√ßa. Com o uso de scripts em MATLAB, foi poss√≠vel aplicar essas teorias de forma pr√°tica e visualiz√°vel, preparando o aluno para desafios mais avan√ßados no campo do **Processamento Gr√°fico**.

---

# Resumo da Aula 06 ‚Äì Processamento Gr√°fico  

---

## 1. Introdu√ß√£o

Esta aula apresenta t√©cnicas fundamentais de **processamento de imagens em n√≠veis de cinza**, com destaque para opera√ß√µes realizadas sobre o **histograma da imagem**, como:

- Binariza√ß√£o  
- Quantiza√ß√£o  
- Splitting  
- Equaliza√ß√£o

Essas t√©cnicas s√£o amplamente utilizadas no pr√©-processamento de imagens para melhorar a qualidade visual ou preparar as imagens para an√°lise posterior por algoritmos de vis√£o computacional.

---

## 2. Histograma de uma Imagem

O histograma √© uma representa√ß√£o gr√°fica que mostra a **distribui√ß√£o dos n√≠veis de cinza** presentes em uma imagem. Ele indica quantos pixels existem para cada n√≠vel de intensidade, variando de 0 (preto) at√© 255 (branco), em imagens de 8 bits.

### Por que usar histogramas?
- Permite entender o contraste e brilho da imagem;
- Facilita a aplica√ß√£o de t√©cnicas de melhoria da qualidade visual;
- Serve como base para opera√ß√µes como binariza√ß√£o, equaliza√ß√£o e quantiza√ß√£o.

---

## 3. Binariza√ß√£o

### Defini√ß√£o:
√â a transforma√ß√£o de uma imagem colorida ou em tons de cinza em uma **imagem bin√°ria (preto e branco)** com apenas dois valores de pixel: **0 (preto)** e **255 (branco)**.

### Objetivo:
Destacar objetos ou regi√µes de interesse separando-as do fundo.

### Limiariza√ß√£o (Thresholding):
- Um valor **limiar (T)** √© escolhido.
- Todos os pixels com valor **menor ou igual a T** s√£o convertidos para **0** (preto).
- Os pixels com valor **maior que T** s√£o convertidos para **255** (branco).

### Desafio:
Escolher o **valor correto de T** para obter bons resultados. Uma t√©cnica comum √© o **m√©todo do vale**, onde T √© definido na regi√£o de menor densidade entre dois picos do histograma.

### Algoritmo B√°sico:
```matlab
for i = 1:linhas
    for j = 1:colunas
        if pixel(i,j) <= limiar
            pixel(i,j) = 0;
        else
            pixel(i,j) = 255;
        end
    end
end
```

---

## 4. Quantiza√ß√£o

### Defini√ß√£o:
Consiste na **redu√ß√£o do n√∫mero de n√≠veis de cinza** de uma imagem. Em vez de usar os 256 n√≠veis poss√≠veis, usam-se poucos n√≠veis (por exemplo, 4 ou 10).

### Objetivo:
- Reduzir a complexidade da imagem;
- Melhorar o contraste em certas aplica√ß√µes;
- Simplificar an√°lises posteriores.

### Como funciona:
- Define-se um passo: `passo = N√≠vel M√°ximo / Quantidade de N√≠veis Desejada`;
- Cada pixel √© arredondado para o m√∫ltiplo mais pr√≥ximo desse passo.

### Exemplo:
Se desejar 4 n√≠veis de cinza, o passo ser√° aproximadamente 64 (256 √∑ 4). Ent√£o:
- Pixels de 0‚Äì32 ‚Üí 0  
- 33‚Äì96 ‚Üí 64  
- 97‚Äì160 ‚Üí 128  
- 161‚Äì255 ‚Üí 192  

### Algoritmo B√°sico:
```matlab
passo = round(max_cinza / qtd_niveis);
pixel(i,j) = round(pixel(i,j)/passo) * passo;
```

---

## 5. Splitting

### Defini√ß√£o:
T√©cnica que **aumenta o contraste da imagem** real√ßando diferen√ßas entre pixels claros e escuros.

### Como funciona:
- Divide-se os pixels em dois grupos:
  - Os com valor abaixo de um **limiar** s√£o escurecidos (subtra√≠do uma constante);
  - Os acima do limiar s√£o clareados (adicionado uma constante).

### Objetivo:
Melhorar a visibilidade de detalhes em imagens com baixo contraste.

### Algoritmo B√°sico:
```matlab
if pixel(i,j) <= limiar
    pixel(i,j) = pixel(i,j) - constante_splitting;
else
    pixel(i,j) = pixel(i,j) + constante_splitting;
end
```

---

## 6. Equaliza√ß√£o do Histograma

### Defini√ß√£o:
T√©cnica que redistribui os valores de intensidade de uma imagem para **melhorar o contraste global**.

### Como funciona:
- Usa-se a **Fun√ß√£o de Distribui√ß√£o Acumulada (CDF)** para mapear os valores atuais de pixel para novos valores, distribuindo-os de forma mais uniforme.

### F√≥rmula Matem√°tica:
$$ S_k = T(r_k) = \sum_{j=0}^{k} P(r_j) $$
Onde:
- $ r_k $: n√≠vel de cinza normalizado (0 ‚â§ rk ‚â§ 1)
- $ P(r_j) $: probabilidade de ocorr√™ncia do n√≠vel de cinza $ r_j $
- $ S_k $: novo valor de pixel ap√≥s equaliza√ß√£o

### Objetivo:
Obter uma imagem com maior nitidez e contraste, facilitando a an√°lise visual e autom√°tica.

### Implementa√ß√£o no MATLAB:
```matlab
B = histeq(A); % Fun√ß√£o pronta do MATLAB
```

---

## 7. Aplica√ß√µes Pr√°ticas das T√©cnicas

As t√©cnicas abordadas nesta aula t√™m diversas aplica√ß√µes em:

- **Medicina**: Melhora de imagens m√©dicas (como mamografias, cromossomos) para diagn√≥sticos mais precisos.
- **Inspe√ß√£o industrial**: Detec√ß√£o de falhas em soldas, superf√≠cies met√°licas etc.
- **Agricultura**: An√°lise de imagens de culturas para detec√ß√£o de doen√ßas ou irregularidades.
- **Vis√£o computacional**: Prepara√ß√£o de imagens para reconhecimento de padr√µes, OCR, segmenta√ß√£o etc.

---

## 8. Exerc√≠cios Propostos

Na aula foram sugeridas implementa√ß√µes pr√°ticas dessas t√©cnicas com imagens espec√≠ficas:

| T√©cnica | Imagens |
|--------|---------|
| **Binariza√ß√£o** | rice.tif, mamografia.bmp, batatas.tif, solda.bmp, laranjas.bmp |
| **Quantiza√ß√£o** | cacau_escuro.tif |
| **Splitting** | cacau_escuro.tif |
| **Equaliza√ß√£o** | cromossomos.bmp, solda.bmp, fundo_cromossomos.bmp, moon.tif, mamografia.bmp |

---

## 9. Considera√ß√µes Finais

As t√©cnicas de manipula√ß√£o de histogramas s√£o ferramentas essenciais no processamento de imagens digitais. Elas permitem:

- Corrigir problemas de ilumina√ß√£o e contraste;
- Destacar caracter√≠sticas importantes da imagem;
- Preparar imagens para etapas posteriores, como segmenta√ß√£o e reconhecimento de padr√µes.

Dominar estas t√©cnicas √© fundamental para quem trabalha com vis√£o artificial, rob√≥tica, sistemas inteligentes ou qualquer √°rea que envolva an√°lise de imagens.

---

# Resumo da Aula 07 ‚Äì Processamento Gr√°fico (PG) ‚Äì 2025  
## Tema: Tipos de Imagens e Filtros

---

### Introdu√ß√£o

Esta aula apresenta os **tipos de imagens digitais utilizados no Octave/Matlab** e explora t√©cnicas de **filtragem digital**, incluindo o uso de **filtros da m√©dia, mediana e m√©dia de m√∫ltiplas imagens**. Esses conceitos s√£o fundamentais para entender como manipular e melhorar a qualidade visual de imagens na √°rea de processamento gr√°fico.

---

## 1. Tipos de Imagens no Octave/Matlab

### 1.1. Imagens Indexadas
- S√£o representadas por duas matrizes:
  - Uma matriz cont√©m √≠ndices que apontam para cores espec√≠ficas.
  - A outra matriz √© o **mapa de cores (colormap)**, contendo os valores RGB correspondentes a cada √≠ndice.
- Cada pixel tem um valor que indica uma linha no colormap.

### 1.2. Imagens de Intensidade (N√≠veis de Cinza)
- Representadas por uma √∫nica matriz.
- Cada elemento da matriz representa a intensidade do pixel, variando entre 0 (preto) e 1 (branco).
- Podem ser convertidas para outros formatos com fun√ß√µes como `mat2gray`.

### 1.3. Imagens Bin√°rias
- Um subtipo especial de imagem de intensidade.
- Os pixels assumem apenas dois valores: 0 (preto) ou 1 (branco).
- Ideal para an√°lise de formas e segmenta√ß√£o.

### 1.4. Imagens RGB (Coloridas)
- Compostas por tr√™s matrizes separadas:
  - Uma para cada componente de cor: **R (Red), G (Green), B (Blue)**.
- Cada pixel tem tr√™s valores normalizados entre 0 e 1.
- Permite total representa√ß√£o de cores.

### 1.5. Convers√£o entre tipos
- √â poss√≠vel converter entre formatos usando fun√ß√µes como:
  - `ind2gray` (imagem indexada para cinza)
  - `gray2ind` (cinza para indexada)
  - `im2bw` (para bin√°ria)
  - `rgb2gray` (RGB para escala de cinza)

---

## 2. Filtro da M√©dia

### 2.1. Objetivo
- Usado para **suaviza√ß√£o de imagens**, reduzindo ru√≠dos aleat√≥rios.
- Suaviza bordas e pode causar **borramento** se aplicado excessivamente.

### 2.2. Funcionamento
- Para cada pixel, calcula-se a m√©dia dos valores dos pixels em sua vizinhan√ßa (geralmente uma janela 3x3, 5x5, etc.).
- A f√≥rmula geral √©:

$$
g(x, y) = \frac{1}{M} \sum_{(m,n) \in S} f(m, n)
$$

Onde:
- $ f(x,y) $: imagem original
- $ g(x,y) $: imagem filtrada
- $ S $: conjunto de pontos na vizinhan√ßa do pixel
- $ M $: n√∫mero total de pixels na vizinhan√ßa

### 2.3. Exemplo Pr√°tico
- Quando aplicado a uma imagem ruidosa, o filtro suaviza as varia√ß√µes bruscas de intensidade.
- Pode ser implementado manualmente no Octave com la√ßos aninhados ou pelo comando `imfilter`.

### 2.4. Efeitos da Aplica√ß√£o
- Quanto maior o tamanho do kernel (janela de filtragem), mais intenso √© o efeito de suaviza√ß√£o.
- No entanto, tamanhos muito grandes podem levar √† perda significativa de detalhes importantes.

---

## 3. Filtro da Mediana

### 3.1. Objetivo
- Especializado na **remo√ß√£o de ru√≠do sal e pimenta (salt and pepper noise)**.
- Preserva melhor as bordas do que o filtro da m√©dia.

### 3.2. Funcionamento
- Substitui o valor do pixel central pela **mediana dos valores em sua vizinhan√ßa**.
- A mediana √© o valor central ap√≥s ordenar todos os valores da janela.

### 3.3. Vantagem sobre o Filtro da M√©dia
- Mais robusto contra picos extremos de ru√≠do (outliers).
- Menos propenso a borrar bordas importantes.

### 3.4. Implementa√ß√£o
- Exemplo de c√°lculo:
  ```
  [75, 77, 77,
   77, 253, 81,
   77, 75, 79]
  ```
  Valores ordenados: [75, 75, 77, 77, 77, 77, 79, 81, 253] ‚Üí Mediana = 77

### 3.5. Aplica√ß√£o Pr√°tica
- Excelente para remover artefatos pontuais sem prejudicar muito os detalhes da imagem.

---

## 4. M√©dia de M√∫ltiplas Imagens

### 4.1. Objetivo
- Reduzir ru√≠do aleat√≥rio em imagens ruidosas.
- Baseia-se na ideia estat√≠stica de que o ru√≠do tende a se cancelar ao somar v√°rias imagens da mesma cena.

### 4.2. Funcionamento
- Dada uma sequ√™ncia de imagens ruidosas $ g_i(x,y) $, a imagem m√©dia √© dada por:

$$
g(x, y) = \frac{1}{M} \sum_{i=1}^{M} g_i(x, y)
$$

### 4.3. Suposi√ß√µes
- As imagens devem conter a mesma cena.
- O ru√≠do deve ser aditivo e aleat√≥rio em cada imagem.

### 4.4. Aplica√ß√µes
- √ötil em fotografia astron√¥mica, microscopia, vis√£o computacional e qualquer contexto onde o ru√≠do afeta a qualidade da imagem.

---

## 5. Exemplos Pr√°ticos no Octave

### 5.1. Uso de comandos b√°sicos
- **Carregar e exibir imagens**:
```octave
A = imread('eight.tif');
imshow(A);
```

- **Adicionar ru√≠do**:
```octave
B = imnoise(A, 'salt & pepper', 0.02);
```

- **Filtrar com m√©dia manual**:
```octave
for i = 2:(lin - fix(size_template/2))
    for j = 2:(col - fix(size_template/2))
        soma = 0;
        for m = i-1:i+1
            for n = j-1:j+1
                soma = soma + B(m,n);
            end
        end
        B(i,j) = soma/(size_template^2);
    end
end
```

- **Filtrar com mediana manual**:
```octave
vetor_elem_mediana = sort(vetor_elem_mediana);
B(i,j) = vetor_elem_mediana(fix(length(vetor_elem_mediana)/2)+1);
```

### 5.2. M√©dia de m√∫ltiplas imagens
```octave
fm = (f1 + f2 + f3 + ... + f10)/10;
imshow(fm);
```

---

## 6. Compara√ß√£o entre os Filtros

| Caracter√≠stica           | Filtro da M√©dia     | Filtro da Mediana       | M√©dia de M√∫ltiplas Imagens |
|--------------------------|---------------------|--------------------------|----------------------------|
| Melhor para              | Ru√≠do Gaussiano     | Ru√≠do Sal e Pimenta      | Ru√≠do Aleat√≥rio            |
| Preserva bordas?         | N√£o (borra bordas)  | Sim                      | Sim                        |
| Complexidade computacional | Baixa               | M√©dia                    | Alta                       |
| Necessita m√∫ltiplas imagens? | N√£o              | N√£o                      | Sim                        |

---

## 7. Considera√ß√µes Finais

Essa aula apresentou os principais **tipos de imagens** e **t√©cnicas de filtragem** usadas no processamento gr√°fico. Dominar essas ferramentas permite ao aluno manipular e melhorar imagens digitalmente, preparando-o para etapas mais avan√ßadas como detec√ß√£o de bordas, segmenta√ß√£o e reconhecimento de padr√µes.

Os filtros estudados s√£o amplamente utilizados em √°reas como **vis√£o computacional, rob√≥tica, sistemas embarcados, medicina e ci√™ncia de dados**.

---

# **Resumo da Aula 08 ‚Äì Processamento Gr√°fico (2025-1)**  

---

## **1. Filtro dos k-Vizinhos Mais Pr√≥ximos**

### **1.1. Conceito**
- √â uma t√©cnica de filtragem local onde o valor central de uma janela √© substitu√≠do pela m√©dia dos **k vizinhos mais pr√≥ximos**, ou seja, os pixels cujos valores de intensidade est√£o mais pr√≥ximos ao pixel central.
- Objetivo: **evitar a inclus√£o de pixels provenientes de bordas ou regi√µes de alto contraste** na m√©dia, mantendo as caracter√≠sticas locais da imagem.

### **1.2. Funcionamento**
1. Define-se uma janela de an√°lise (por exemplo, 3x3, 5x5).
2. Identifica-se os **k pixels cujos valores de cinza est√£o mais pr√≥ximos do pixel central**.
3. Calcula-se a m√©dia desses k valores e atribui-se ao pixel central.

### **1.3. Exemplo Pr√°tico**
Dada uma janela de 5x5:
```
| 20 | 30 | 24 | 34 | 60 |
| 23 | 24 | 56 | 67 | 88 |
| 12 | 23 | 35 | 65 | 66 |
| 11 | 22 | 99 | 99 | 99 |
| 12 | 12 | 12 | 22 | 22 |
```
Para `k = 9`, selecionam-se os 9 valores mais pr√≥ximos de 35:
- Os valores mais pr√≥ximos s√£o: 22, 22, 22, 23, 23, 24, 24, 30, 34
- M√©dia: `(22 + 22 + 22 + 23 + 23 + 24 + 24 + 30 + 34) / 9 = 22,33`

### **1.4. Aplica√ß√£o**
- √ötil para **reduzir ru√≠do sem perder muitos detalhes da imagem**, especialmente em regi√µes com bordas.

---

## **2. Templates e Convolu√ß√£o**

### **2.1. O que s√£o Templates?**
- Tamb√©m chamados de **m√°scaras** ou **filtros**, s√£o matrizes usadas para aplicar opera√ß√µes em uma regi√£o espec√≠fica da imagem.
- Cada elemento da m√°scara √© multiplicado pelo valor correspondente da imagem, e o resultado √© somado para obter o novo valor do pixel central.

### **2.2. F√≥rmula Geral**
Seja `w` uma m√°scara de tamanho `n x n`, o novo valor do pixel `g(x,y)` √© dado por:

$$
g(x,y) = \sum_{i=1}^{k} w_i \cdot f(x,y)_i
$$

Onde:
- `f(x,y)_i`: valor do pixel na posi√ß√£o i da vizinhan√ßa
- `w_i`: peso associado √† posi√ß√£o i na m√°scara
- `k`: n√∫mero total de pixels na vizinhan√ßa (`n x n`)

### **2.3. Tipos de Convolu√ß√£o**
#### **Convolu√ß√£o Aperi√≥dica**
- Preenche com zeros as bordas da imagem onde n√£o h√° dados suficientes para aplicar a m√°scara.
- Resultado: **imagem menor** que a original.

#### **Convolu√ß√£o Peri√≥dica**
- Trata a imagem como se fosse peri√≥dica, ou seja, considera os pixels das bordas como adjacentes √†s extremidades opostas.
- Resultado: **imagem com mesmo tamanho da original**.

---

## **3. Filtros Espaciais**

### **3.1. Filtro Passa-Baixas (Low-Pass Filter)**
- Tem como objetivo **suavizar a imagem**, reduzindo ru√≠dos e pequenas varia√ß√µes de intensidade.
- Utiliza m√°scaras com **valores positivos** e soma igual a 1.
- Realiza uma m√©dia ponderada da vizinhan√ßa do pixel.

#### **Exemplos de M√°scaras Comuns**
```matlab
[1 1 1]
[1 1 1] * 1/9
[1 1 1]

[0 1 0]
[1 1 1] * 1/5
[0 1 0]
```

#### **Aplica√ß√µes**
- Remo√ß√£o de ru√≠dos
- Borramento de imagens
- Prepara√ß√£o para outras opera√ß√µes (como detec√ß√£o de bordas)

---

### **3.2. Filtro Passa-Altas (High-Pass Filter)**
- Tem como objetivo **real√ßar detalhes e bordas**, enfatizando transi√ß√µes abruptas de intensidade.
- As m√°scaras t√™m soma igual a zero ou pr√≥ximo de zero.
- Destacam √°reas de alta frequ√™ncia (bordas, cantos).

#### **Exemplos de M√°scaras Comuns**
```matlab
[ 0 -1  0]
[-1  5 -1]
[ 0 -1  0]

[-1 -1 -1]
[-1  8 -1]
[-1 -1 -1]

[ 1  2  1]
[ 2 -5  2]
[ 1  2  1]
```

#### **Importante**
- Ap√≥s aplicar o filtro passa-altas, √© necess√°rio **ajustar os valores para o intervalo [0,255]**, pois podem ocorrer valores negativos.

#### **Aplica√ß√µes**
- Detec√ß√£o de bordas
- Agudiza√ß√£o de imagens
- Melhoria visual de imagens borradas

---

## **4. Implementa√ß√£o Pr√°tica em MATLAB/Octave**

### **4.1. Exemplo de C√≥digo ‚Äì Filtro Passa-Baixas**
```matlab
k = imread('lena.bmp');
figure, imshow(k);
k = rgb2gray(k);
[lin, col] = size(k);

% Defini√ß√£o da m√°scara
t = (1/5) * [0 1 0; 1 1 1; 0 1 0];

for i = 2:lin-1
    for j = 2:col-1
        soma = 0;
        u = 1;
        for linha = i-1:i+1
            p = 1;
            for coluna = j-1:j+1
                soma = soma + (k(linha, coluna) * t(u,p));
                p = p + 1;
            end
            u = u + 1;
        end
        k2(i,j) = soma;
    end
end

figure, imshow(k2);
```

### **4.2. Exemplo de C√≥digo ‚Äì Filtro Passa-Altas**
```matlab
k = imread('lena.bmp');
figure, imshow(k);
k = rgb2gray(k);
[lin, col] = size(k);

% Defini√ß√£o da m√°scara
t = [0 -1 0; -1 5 -1; 0 -1 0];

for i = 2:lin-1
    for j = 2:col-1
        soma = 0;
        u = 1;
        for linha = i-1:i+1
            p = 1;
            for coluna = j-1:j+1
                soma = soma + (k(linha, coluna) * t(u,p));
                p = p + 1;
            end
            u = u + 1;
        end
        k2(i,j) = soma;
    end
end

figure, imshow(k2);
```

---

## **5. Compara√ß√£o entre Filtros**

| Caracter√≠stica | Filtro Passa-Baixas | Filtro Passa-Altas |
|----------------|----------------------|---------------------|
| Finalidade     | Suavizar imagem      | Real√ßar detalhes    |
| Efeito         | Reduz ru√≠do          | Detecta bordas      |
| M√°scara        | Coeficientes positivos, soma = 1 | Coeficientes positivos e negativos, soma ‚âà 0 |
| Resultado Visual | Imagem mais suave, menos definida | Imagem mais n√≠tida, com bordas destacadas |

---

## **6. Exerc√≠cios Recomendados**

1. **Implemente o algoritmo dos k-vizinhos** em Octave/MATLAB.
   - Use diferentes valores de `k`.
   - Compare os resultados em imagens como Lena, batatas e rice.

2. **Compare filtros passa-altas e passa-baixas**
   - Aplique ambos os filtros nas mesmas imagens.
   - Use diferentes m√°scaras para o passa-altas.
   - Mostre lado a lado as imagens resultantes.

3. **Adicione ru√≠do artificialmente** a uma imagem e aplique os dois tipos de filtro.
   - Avalie qual filtro √© mais eficaz na remo√ß√£o de ru√≠do.

---

## **7. Considera√ß√µes Finais**

Os filtros espaciais, como o **filtro dos k-vizinhos mais pr√≥ximos**, **passa-baixas** e **passa-altas**, s√£o ferramentas essenciais no processamento de imagens. Eles permitem melhorar a qualidade visual, real√ßar caracter√≠sticas importantes e preparar imagens para an√°lises posteriores, como segmenta√ß√£o e reconhecimento de padr√µes.

Essas t√©cnicas formam a base para opera√ß√µes mais complexas, como detec√ß√£o de bordas, identifica√ß√£o de objetos e an√°lise autom√°tica de imagens em sistemas de vis√£o computacional.

---

# Resumo da Aula 09 ‚Äì Processamento Gr√°fico  

---

## 1. Introdu√ß√£o

Esta aula aborda t√©cnicas avan√ßadas de processamento de imagens, incluindo:

- Filtros direcionais para realce de bordas;
- Filtro High-Boost;
- Opera√ß√µes aritm√©ticas e l√≥gicas entre pixels de imagens.

Essas t√©cnicas s√£o fundamentais no pr√©-processamento e p√≥s-processamento de imagens digitais, especialmente quando o objetivo √© real√ßar caracter√≠sticas importantes ou preparar as imagens para an√°lise por sistemas computacionais.

---

## 2. Filtros por Dire√ß√µes (Filtragem Direcional)

### Defini√ß√£o:
S√£o filtros utilizados para real√ßar bordas em uma imagem segundo dire√ß√µes espec√≠ficas, como norte, sul, leste, oeste, nordeste, etc.

### Objetivo:
Detectar mudan√ßas bruscas na intensidade dos pixels, que indicam bordas ou contornos em uma imagem.

### Funcionamento:
- Cada m√°scara (ou kernel) tem pesos diferentes distribu√≠dos em uma matriz 3x3.
- A soma dos coeficientes da m√°scara geralmente √© zero para enfatizar as bordas.
- O nome da m√°scara indica a dire√ß√£o ortogonal ao limite de borda que ser√° real√ßado. Por exemplo, a m√°scara ‚Äúnorte‚Äù real√ßa bordas horizontais.

### Exemplos de M√°scaras:

| Dire√ß√£o | M√°scara |
|--------|---------|
| Norte | $\begin{bmatrix} -1 & -2 & -1 \\ 1 & 1 & 1 \\ 1 & 1 & 1 \end{bmatrix}$ |
| Sul | $\begin{bmatrix} 1 & 1 & 1 \\ 1 & 2 & 1 \\ -1 & -1 & -1 \end{bmatrix}$ |
| Leste | $\begin{bmatrix} -1 & 1 & -1 \\ -2 & 1 & -1 \\ -1 & 1 & -1 \end{bmatrix}$ |
| Oeste | $\begin{bmatrix} -1 & 1 & -1 \\ -1 & 2 & -1 \\ -1 & 1 & -1 \end{bmatrix}$ |
| Nordeste | $\begin{bmatrix} -1 & -1 & 1 \\ -1 & 1 & -1 \\ 1 & -1 & -1 \end{bmatrix}$ |
| Sudoeste | $\begin{bmatrix} 1 & -1 & -1 \\ -1 & 1 & -1 \\ -1 & -1 & 1 \end{bmatrix}$ |

> Estas m√°scaras podem ser implementadas usando convolu√ß√£o nas imagens.

---

## 3. Exerc√≠cios Pr√°ticos com Filtros Direcionais

### Sugest√µes de Aplica√ß√£o:
- **Imagem recomendada:** rice_binary.png
- Aplicar todos os 8 tipos de m√°scaras direcionais e exibir todas as imagens lado a lado para compara√ß√£o visual.

### Tarefas:
- Implementar convolu√ß√£o aperi√≥dica e peri√≥dica.
- Transformar fun√ß√µes de m√©dia, mediana e k-vizinhos em blocos reutiliz√°veis.
- Adicionar ru√≠do sal e pimenta √† imagem e aplicar os filtros para comparar resultados.

---

## 4. Filtro High-Boost

### Defini√ß√£o:
√â um filtro que real√ßa bordas e aumenta o contraste de uma imagem, combinando a imagem original com uma vers√£o filtrada passa-altas.

### F√≥rmula Geral:
$$ g(x,y) = A \cdot f(x,y) - LowPass(f(x,y)) $$

Onde:
- $ f(x,y) $: imagem original
- $ LowPass(f(x,y)) $: imagem suavizada (filtro passa-baixa)
- $ A $: fator de amplifica√ß√£o da imagem original

### Varia√ß√£o:
Pode ser reescrito como:
$$ g(x,y) = (A - 1) \cdot f(x,y) + HighPass(f(x,y)) $$

### Casos Espec√≠ficos:
- Se $ A = 1 $: o filtro se torna um passa-altas tradicional.
- Se $ A > 1 $: parte da imagem original √© adicionada, preservando informa√ß√µes de baixa frequ√™ncia e real√ßando bordas.

### Aplica√ß√£o Pr√°tica:
- √ötil para real√ßar detalhes finos sem perder completamente a apar√™ncia original da imagem.
- Usado em imagens m√©dicas, sat√©lites e em qualquer contexto onde o realce de bordas √© desej√°vel.

---

## 5. Exemplo de C√≥digo MATLAB ‚Äì High-Boost

```matlab
% Carregar imagem
J = imread('kids.png');

% Par√¢metros
p1 = 1.1; p2 = 1.15; p3 = 1.2;

% Calcular pesos das m√°scaras
w1 = 9*p1 - 1; w2 = 9*p2 - 1; w3 = 9*p3 - 1;

% Criar m√°scaras
m1 = [-1 -1 -1; -1 w1 -1; -1 -1 -1];
m2 = [-1 -1 -1; -1 w2 -1; -1 -1 -1];
m3 = [-1 -1 -1; -1 w3 -1; -1 -1 -1];

% Aplicar filtros
L1 = filter2(m1, J);
L2 = filter2(m2, J);
L3 = filter2(m3, J);

% Limitar valores entre 0 e 255
L1 = max(min(L1, 255), 0);
L2 = max(min(L2, 255), 0);
L3 = max(min(L3, 255), 0);

% Normalizar
L1 = L1 / 255; L2 = L2 / 255; L3 = L3 / 255;

% Mostrar resultados
figure;
subplot(2,2,1); imshow(J); title('Original');
subplot(2,2,2); imshow(L1); title('High-Boost p1');
subplot(2,2,3); imshow(L2); title('High-Boost p2');
subplot(2,2,4); imshow(L3); title('High-Boost p3');
```

---

## 6. Opera√ß√µes Aritm√©ticas entre Pixels

### Defini√ß√£o:
Opera√ß√µes realizadas pixel a pixel entre duas ou mais imagens, como adi√ß√£o, subtra√ß√£o, multiplica√ß√£o e divis√£o.

### Principais Opera√ß√µes:
- **Adi√ß√£o:** $ p + q $
  - Usada para reduzir ru√≠do (m√©dia de m√∫ltiplas imagens).
- **Subtra√ß√£o:** $ p - q $
  - Detecta diferen√ßas entre imagens (√∫til para detec√ß√£o de movimento).
- **Multiplica√ß√£o:** $ p \times q $
  - Realiza mascaramento ou ajuste localizado de brilho.
- **Divis√£o:** $ p \div q $
  - Utilizada para normaliza√ß√£o ou corre√ß√£o de ilumina√ß√£o.

---

## 7. Opera√ß√µes L√≥gicas entre Pixels

### Defini√ß√£o:
Opera√ß√µes bin√°rias realizadas entre pixels de imagens bin√°rias (0 ou 1).

### Principais Opera√ß√µes:
- **AND (E):** $ p \land q $
- **OR (OU):** $ p \lor q $
- **NOT (N√ÉO):** $ \lnot q $
- **XOR (OU exclusivo):** $ p \oplus q $

### Aplica√ß√µes:
- Segmenta√ß√£o de objetos
- Combina√ß√£o de m√°scaras
- Detec√ß√£o de diferen√ßas entre imagens

---

## 8. Exemplo de Aplica√ß√£o no MATLAB ‚Äì Opera√ß√µes L√≥gicas

```matlab
% Carregar e converter imagens
BW1 = im2bw(imread('image1.png'), 0.5);
BW2 = im2bw(imread('image2.png'), 0.5);

% Opera√ß√µes l√≥gicas
and_result = BW1 & BW2;
or_result = BW1 | BW2;
xor_result = xor(BW1, BW2);

% Visualizar resultados
figure;
subplot(2,2,1); imshow(BW1); title('Imagem 1');
subplot(2,2,2); imshow(BW2); title('Imagem 2');
subplot(2,2,3); imshow(and_result); title('AND');
subplot(2,2,4); imshow(or_result); title('OR');
figure;
imshow(xor_result); title('XOR');
```

---

## 9. Subtra√ß√£o de Imagens ‚Äì Detec√ß√£o de Movimento

### Defini√ß√£o:
T√©cnica que compara duas imagens para detectar mudan√ßas ou movimento entre elas.

### F√≥rmula:
$$ g(x,y) = f(x,y) - h(x,y) $$
Onde:
- $ f(x,y) $: imagem atual
- $ h(x,y) $: imagem de fundo ou refer√™ncia

### Etapas:
1. Carregar duas imagens.
2. Converter para tons de cinza, se necess√°rio.
3. Aplicar `imabsdiff()` para obter a diferen√ßa absoluta.
4. Complementar a imagem para destacar √°reas modificadas.

### Exemplo de C√≥digo:
```matlab
g1 = imread('cromossomos.bmp');
g2 = imread('fundo_cromossomos.bmp');
g3 = imabsdiff(g2, g1);
g4 = imcomplement(g3);

figure; imshow(g1); title('Imagem Original');
figure; imshow(g2); title('Fundo');
figure; imshow(g3); title('Diferen√ßa');
figure; imshow(g4); title('Diferen√ßa Complementada');
```

---

## 10. Considera√ß√µes Finais

As t√©cnicas apresentadas nesta aula s√£o essenciais para manipula√ß√£o e an√°lise de imagens digitais. Elas permitem:

- Detectar bordas e contornos em diversas dire√ß√µes;
- Real√ßar detalhes com o filtro High-Boost;
- Comparar imagens atrav√©s de opera√ß√µes matem√°ticas e l√≥gicas;
- Identificar mudan√ßas ou movimentos em sequ√™ncias de imagens.

Estas ferramentas s√£o amplamente utilizadas em aplica√ß√µes como vis√£o artificial, rob√≥tica, medicina, seguran√ßa e automa√ß√£o industrial.

---

# Resumo da Aula 10 ‚Äì Processamento Gr√°fico (PG) ‚Äì 2025  
## Tema: Segmenta√ß√£o de Imagens

---

### Introdu√ß√£o

A segmenta√ß√£o √© uma etapa fundamental no processamento de imagens, pois busca dividir uma imagem em partes ou objetos significativos, facilitando a interpreta√ß√£o visual e an√°lise posterior. Essa t√©cnica √© amplamente utilizada em √°reas como vis√£o computacional, diagn√≥stico m√©dico por imagem, rob√≥tica e sistemas embarcados.

Nesta aula, foram abordadas duas grandes categorias de segmenta√ß√£o:

1. **Segmenta√ß√£o por limiariza√ß√£o**
2. **Segmenta√ß√£o baseada em regi√µes**

Ambas s√£o t√©cnicas essenciais para identificar e separar objetos de interesse no fundo da imagem ou entre diferentes regi√µes.

---

## 1. Segmenta√ß√£o por Limiariza√ß√£o (Thresholding)

### 1.1. Defini√ß√£o

A **limiariza√ß√£o** √© uma t√©cnica simples e eficaz que transforma uma imagem em n√≠veis de cinza em uma imagem bin√°ria, dividindo-a em duas ou mais classes com base em valores de intensidade.

### 1.2. Objetivo

O objetivo √© **separar os objetos de interesse do fundo da imagem**, agrupando pixels com caracter√≠sticas semelhantes (como brilho ou cor).

### 1.3. Tipos de Limiariza√ß√£o

Existem tr√™s principais tipos de limiariza√ß√£o:

#### a) **Limiariza√ß√£o Global**
- Utiliza **um √∫nico valor de limiar (T)** aplicado a toda a imagem.
- Ideal quando as condi√ß√µes de ilumina√ß√£o s√£o uniformes.
- Exemplo:
  ```
  se f(x,y) ‚â• T ‚Üí g(x,y) = 1 (objeto)
  se f(x,y) < T ‚Üí g(x,y) = 0 (fundo)
  ```

#### b) **Limiariza√ß√£o Local**
- Usa **v√°rios limiares**, calculados com base em propriedades locais (por exemplo, m√©dia de intensidade na vizinhan√ßa).
- Mais eficiente em imagens com varia√ß√£o de ilumina√ß√£o.

#### c) **Limiariza√ß√£o Din√¢mica**
- Leva em conta **coordenadas espaciais (x, y)** e propriedades locais.
- √ötil em imagens com fundos n√£o uniformes ou objetos com diferentes contrastes.

### 1.4. Algoritmo B√°sico de Limiariza√ß√£o

```matlab
% Define o limiar T
for linha = 1 at√© quantidade_linhas
    for coluna = 1 at√© quantidade_colunas
        if pixel(linha, coluna) < T
            pixel(linha, coluna) = 0; % fundo
        else
            pixel(linha, coluna) = 1; % objeto
        end
    end
end
```

### 1.5. Vantagens e Desvantagens

| Caracter√≠stica | Vantagem | Desvantagem |
|----------------|----------|-------------|
| Simplicidade   | ‚úÖ F√°cil implementa√ß√£o | ‚ùå Sens√≠vel √† escolha do limiar |
| Velocidade     | ‚úÖ R√°pida | ‚ùå Pode falhar em imagens complexas |
| Aplicabilidade | ‚úÖ √ötil para imagens com contraste claro | ‚ùå Requer ajuste manual |

---

## 2. Segmenta√ß√£o Baseada em Regi√µes

### 2.1. Defini√ß√£o

Essa t√©cnica divide a imagem em regi√µes com base na **similaridade de propriedades locais**, como intensidade, cor ou textura. √â uma abordagem mais robusta que a limiariza√ß√£o, especialmente em imagens com m√∫ltiplos objetos e fundos irregulares.

### 2.2. Princ√≠pios Gerais

- Come√ßa com a sele√ß√£o de **sementes (pixels iniciais)**.
- Os pixels adjacentes s√£o adicionados √†s regi√µes se forem **semelhantes** √†s sementes.
- O processo continua at√© que uma **condi√ß√£o de parada** seja atingida (ex.: limite de tamanho ou diferen√ßa de intensidade).

### 2.3. Etapas do Algoritmo

1. **Escolher sementes** (pixels iniciais).
2. Para cada pixel vizinho:
   - Verifica se √© **similar** √† regi√£o atual (usando um crit√©rio como diferen√ßa absoluta de intensidade).
   - Se sim, **adiciona-o √† regi√£o**.
3. Repete at√© n√£o haver mais pixels candidatos.

### 2.4. Crit√©rios de Similaridade Comuns

- Diferen√ßa absoluta de intensidade:
  $$
  \| I(x, y) - I(s) \| \leq T
  $$
  Onde:
  - $ I(x, y) $: intensidade do pixel candidato
  - $ I(s) $: intensidade da semente
  - $ T $: limiar de toler√¢ncia

- Conectividade:
  - Usar conectividade-4 ou conectividade-8 para definir quais pixels podem ser agregados.

### 2.5. Vantagens e Desvantagens

| Caracter√≠stica | Vantagem | Desvantagem |
|----------------|----------|-------------|
| Precis√£o       | ‚úÖ Melhor defini√ß√£o de contornos | ‚ùå Mais complexo computacionalmente |
| Flexibilidade  | ‚úÖ Adapta-se a diferentes padr√µes | ‚ùå Depende da escolha inicial das sementes |
| Aplicabilidade | ‚úÖ √ötil em imagens complexas | ‚ùå Tempo maior de processamento |

---

## 3. Compara√ß√£o entre as T√©cnicas

| Crit√©rio | Limiariza√ß√£o | Segmenta√ß√£o por Regi√µes |
|---------|--------------|--------------------------|
| Complexidade | Baixa | M√©dia a alta |
| Depend√™ncia do limiar | Alta | Baixa |
| Trabalha com m√∫ltiplas classes | Sim (com m√∫ltiplos limiares) | Sim |
| Trabalha com formas irregulares | N√£o muito bem | Sim |
| Necessita pr√©-processamento | Sim (ajuste de contraste) | Nem sempre |
| Aplica√ß√µes t√≠picas | Detec√ß√£o de objetos simples, OCR | An√°lise m√©dica, reconhecimento de padr√µes |

---

## 4. Exemplos Pr√°ticos

### Exemplo 1 ‚Äì Limiariza√ß√£o

Dada uma imagem `I`, define-se um valor de limiar `T`:

```matlab
I_binary = I > T;
imshow(I_binary);
```

### Exemplo 2 ‚Äì Crescimento de Regi√£o

Implementa√ß√£o de crescimento de regi√£o com duas sementes:

```matlab
% Define sementes
s1 = [3, 2]; % coordenadas da primeira semente
s2 = [3, 4]; % coordenadas da segunda semente

% Define limiar de toler√¢ncia
T = 10;

% Inicializa regi√µes
R1 = {s1};
R2 = {s2};

% Loop para agregar pixels similares
while h√°_pixels_candidatos
    for cada pixel na borda de R1
        verifica se vizinhos s√£o similares
        se sim, adiciona a R1
    end
    for cada pixel na borda de R2
        verifica se vizinhos s√£o similares
        se sim, adiciona a R2
    end
end
```

---

## 5. Considera√ß√µes Finais

A **segmenta√ß√£o de imagens** √© um dos pilares do processamento gr√°fico, permitindo extrair informa√ß√µes relevantes de imagens digitais. As t√©cnicas apresentadas ‚Äî **limiariza√ß√£o** e **segmenta√ß√£o baseada em regi√µes** ‚Äî oferecem abordagens complementares:

- **Limiariza√ß√£o** √© ideal para aplica√ß√µes r√°pidas e simples, onde o contraste entre objetos e fundo √© bem definido.
- **Segmenta√ß√£o por regi√µes** √© mais adequada para imagens complexas, com m√∫ltiplos objetos e varia√ß√µes de ilumina√ß√£o.

Dominar essas t√©cnicas permite ao aluno desenvolver solu√ß√µes pr√°ticas em √°reas como **reconhecimento de padr√µes, detec√ß√£o de defeitos em produtos, an√°lise de imagens m√©dicas e classifica√ß√£o autom√°tica de objetos**.

Claro! Abaixo est√° um **resumo detalhado e completo** sobre os assuntos tratados na **Aula 11 ‚Äì Processamento Gr√°fico (2025-1)**, com base no conte√∫do do arquivo anexado **"UA 03 - Aula 11 - PG 2025-1.pdf"**. O texto foi estruturado de forma clara, did√°tica e com riqueza de detalhes, para que voc√™ possa copiar e colar diretamente em um documento do Word.

---

# **Resumo da Aula 11 ‚Äì Processamento Gr√°fico (2025-1)**  
**Disciplina:** Processamento Gr√°fico  
**Professores:** Siovani Ferrari e M√°rio  
**Campus Sorocaba ‚Äì Universidade Federal de S√£o Carlos (UFSCar)**

---

## **1. Labeling (Rotulagem de Objetos)**

### **1.1. Conceito**
- **Labeling** √© uma t√©cnica usada para identificar e rotular objetos distintos em uma imagem bin√°ria.
- Cada objeto ou regi√£o conexa recebe uma etiqueta √∫nica, facilitando a an√°lise individual dos elementos presentes na imagem.

### **1.2. Funcionamento**
- A varredura ocorre pixel por pixel, da esquerda para a direita e de cima para baixo.
- Utiliza-se a **conectividade 4**, ou seja, considera-se como vizinhos apenas os pixels acima e √† esquerda do pixel atual.

#### **Passos principais:**
1. Se o pixel for branco (valor 1):
   - Verifica os pixels acima e √† esquerda (j√° analisados).
   - Se ambos forem pretos (valor 0), atribui-se uma nova etiqueta.
   - Se um ou ambos tiverem etiquetas:
     - Se as etiquetas forem iguais ‚Üí mant√©m-se a mesma etiqueta.
     - Se forem diferentes ‚Üí escolhe-se uma etiqueta e registra-se a equival√™ncia entre elas.
2. Ap√≥s a varredura, substitui-se todas as etiquetas equivalentes pela principal.

### **1.3. Exemplo Pr√°tico**
Dada uma imagem bin√°ria, ap√≥s aplicar o **labeling**, cada objeto √© identificado com um n√∫mero √∫nico, como:
```
| 0 | 1 | 1 | 1 | 0 |
| 0 | 1 | 1 | 0 | 0 |
| 0 | 0 | 2 | 2 | 2 |
| 0 | 0 | 0 | 3 | 3 |
```

### **1.4. Implementa√ß√£o em Octave/MATLAB**
```matlab
A = imread('blobs.tif');
A = im2bw(A, 0.3);
rotulada = bwlabel(~A, 4); % Aplica labeling com conectividade 4
qtd_regioes = max(max(rotulada));
props = regionprops(rotulada, 'Centroid');

for k = 1:qtd_regioes
    pos_centroid = props(k).Centroid;
    text(pos_centroid(1)-15, pos_centroid(2), num2str(k), ...
        'FontSize', 14, 'FontWeight','Bold', 'Color','Red');
end
```

---

## **2. Representa√ß√£o e Descri√ß√£o de Objetos**

Ap√≥s identificar os objetos, √© necess√°rio descrev√™-los de forma quantitativa e qualitativa, usando caracter√≠sticas externas (fronteiras) ou internas (pixels).

### **2.1. Representa√ß√£o por Fronteiras**
- Foca nas bordas dos objetos.
- √ötil para an√°lise de formas, contornos e propriedades geom√©tricas.

#### **Tipos de representa√ß√µes:**
1. **Aproxima√ß√µes Poligonais**
   - Representam a fronteira com segmentos de reta.
   - Objetivo: capturar a ess√™ncia da forma com poucos pontos.
   - T√©cnica: definir os v√©rtices do pol√≠gono que melhor representa a curva.

2. **Sequ√™ncia de Segmentos**
   - Representa o contorno como uma sequ√™ncia de primitivas (como curvas, linhas).
   - Usada em classifica√ß√£o de cromossomos e OCR (Reconhecimento √ìtico de Caracteres).

3. **Inscri√ß√£o de Pol√≠gono Convexo**
   - Determina os pontos mais distantes na fronteira.
   - Une esses pontos para formar um pol√≠gono convexo.
   - √ötil para simplificar formas complexas.

4. **Divis√£o Recursiva do Contorno**
   - Divide a curva at√© atender um crit√©rio de erro.
   - Come√ßa com dois pontos extremos e adiciona novos pontos onde a dist√¢ncia perpendicular excede um limiar.

5. **C√≥digo da Cadeia (Chain Code)**
   - Representa o contorno como uma sequ√™ncia de dire√ß√µes (4 ou 8 dire√ß√µes).
   - Exemplo (8 dire√ß√µes): `076666553321212`.
   - Vantagem: compacta.
   - Problema: sens√≠vel ao ponto inicial e rota√ß√£o.

6. **Assinaturas (Signature)**
   - Representa a dist√¢ncia do centr√≥ide √† fronteira em fun√ß√£o do √¢ngulo.
   - Plotagem: gr√°fico polar da dist√¢ncia vs. √¢ngulo.
   - Vantagens: tolerante ao ru√≠do, f√°cil de calcular.
   - Limita√ß√£o: centr√≥ide n√£o pode estar oculto.

---

## **3. Exerc√≠cios Propostos**

### **3.1. Contagem de Objetos**
- **Objetivo:** Identificar e contar objetos em uma imagem bin√°ria.
- **Imagem utilizada:** `blobs.tif`
- **T√©cnica:** Usar `bwlabel` e `regionprops`.

### **3.2. An√°lise de √Åreas**
- **Objetivo:** Mostrar a √°rea de cada objeto no centroide correspondente.
- **Fun√ß√µes √∫teis:** `regionprops(...,'Area')`, `text`.

### **3.3. Rotulagem com Conectividade 8**
- **Objetivo:** Comparar resultados com conectividade 4 e 8.
- **Mudan√ßa no c√≥digo:** alterar o segundo par√¢metro de `bwlabel`.

### **3.4. Separa√ß√£o de Objetos Individuais**
- **Objetivo:** Separar cada gr√£o de arroz em uma nova imagem.
- **Imagem utilizada:** `rice_binary.png`
- **T√©cnica:** Usar `PixelList` do `regionprops`.

### **3.5. Detec√ß√£o de Borda de Objetos**
- **Objetivo:** Detectar e visualizar a borda de cada objeto.
- **Fun√ß√£o:** `bwperim`

---

## **4. Etapas do Processamento de Imagens**

O processamento de imagens pode ser dividido em tr√™s n√≠veis:

| N√≠vel | Objetivo | Exemplos |
|-------|----------|----------|
| **Baixo n√≠vel** | Melhorar a qualidade visual | Realce, restaura√ß√£o, transforma√ß√µes |
| **N√≠vel intermedi√°rio** | Representar e descrever objetos | Segmenta√ß√£o, rotulagem, extra√ß√£o de caracter√≠sticas |
| **Alto n√≠vel** | Interpretar o conte√∫do | Reconhecimento de padr√µes, classifica√ß√£o |

---

## **5. Aplica√ß√µes Relevantes**

- **OCR (Reconhecimento √ìtico de Caracteres)**
- **ECG (Eletrocardiograma) e EEG (Eletroencefalograma)**
- **Classifica√ß√£o de c√©lulas e cromossomos**
- **Inspe√ß√£o autom√°tica industrial**
- **Sistemas de recupera√ß√£o de imagens baseados em conte√∫do (CBIR)**
- **An√°lise de formas em biologia, medicina e rob√≥tica**

---

## **6. Considera√ß√µes Finais**

A **identifica√ß√£o e descri√ß√£o de objetos** em imagens √© um passo fundamental no processamento gr√°fico, especialmente para aplica√ß√µes como reconhecimento de padr√µes, an√°lise de formas e sistemas de vis√£o computacional.

As t√©cnicas apresentadas nesta aula ‚Äî **labeling**, **representa√ß√£o de fronteiras**, **c√≥digo da cadeia**, **assinaturas** e **an√°lise de √°reas** ‚Äî s√£o ferramentas poderosas para extrair informa√ß√µes relevantes de imagens segmentadas, permitindo an√°lises posteriores mais avan√ßadas.

Com a implementa√ß√£o pr√°tica em Octave/MATLAB, √© poss√≠vel automatizar esse processo e aplic√°-lo a diversos contextos reais, como agricultura, medicina, ind√∫stria e seguran√ßa.

# Resumo da Aula 12 ‚Äì Processamento Gr√°fico  

---

## 1. Introdu√ß√£o

Nesta aula s√£o abordadas t√©cnicas de **representa√ß√£o e descri√ß√£o de regi√µes em imagens digitais**, que permitem extrair informa√ß√µes quantitativas e qualitativas sobre objetos identificados em uma imagem. Essas t√©cnicas s√£o fundamentais para an√°lise e interpreta√ß√£o de imagens em sistemas de vis√£o artificial, rob√≥tica, medicina e automa√ß√£o industrial.

---

## 2. Representa√ß√£o por Regi√µes

Na an√°lise de imagens, ap√≥s a segmenta√ß√£o, √© comum representar as regi√µes identificadas por meio de descritores escalares, ou seja, medidas num√©ricas que caracterizam propriedades das formas presentes na imagem.

### Principais Descritores Escalares:
- N√∫mero de Euler  
- Excentricidade  
- Compacidade  
- Esqueletoniza√ß√£o

---

## 3. N√∫mero de Euler

### Defini√ß√£o:
O **N√∫mero de Euler (E)** √© uma medida topol√≥gica que relaciona o n√∫mero de componentes conectadas (C) e o n√∫mero de furos (Holes, H) em uma regi√£o:

$$
E = C - H
$$

### Interpreta√ß√£o:
- Indica a complexidade da estrutura da regi√£o.
- √ötil para identificar caracter√≠sticas como buracos em objetos.
- Sens√≠vel √† conectividade dos pixels.

### Exemplo:
Se uma imagem cont√©m 3 objetos conectados e 1 buraco dentro de um deles, ent√£o:
- C = 3  
- H = 1  
- E = 3 ‚Äì 1 = 2

---

## 4. Excentricidade

### Defini√ß√£o:
√â a raz√£o entre o **eixo maior (D)** e o **eixo menor (d)** de uma figura:

$$
E = \frac{D}{d}
$$

### O que representa?
- Mede qu√£o alongada ou el√≠ptica uma figura √©.
- Um c√≠rculo tem excentricidade igual a 1.
- Figuras mais alongadas t√™m excentricidade maior que 1.

### Aplica√ß√£o:
√ötil para diferenciar objetos com formatos distintos, como barras longas vs. esferas.

---

## 5. Compacidade

### Defini√ß√£o:
Relaciona o **per√≠metro ao quadrado** com a **√°rea** da regi√£o:

$$
\text{Compacidade} = \frac{\text{Per√≠metro}^2}{\text{√Årea}}
$$

### Caracter√≠sticas:
- √â uma medida adimensional.
- Insens√≠vel a escala e orienta√ß√£o da figura.
- Valores menores indicam figuras mais compactas (como c√≠rculos).

### Exemplo:
Um c√≠rculo √© a forma mais compacta poss√≠vel. √Ä medida que a figura se torna mais irregular ou alongada, sua compacidade aumenta.

---

## 6. Esqueletoniza√ß√£o

### Defini√ß√£o:
T√©cnica que reduz uma regi√£o a seu **"esqueleto"**, mantendo a topologia e a forma original da figura.

### Objetivo:
- Simplificar a representa√ß√£o de formas;
- Facilitar an√°lise de estruturas lineares ou ramificadas;
- √ötil em aplica√ß√µes como reconhecimento de caracteres, vasos sangu√≠neos, folhas, etc.

---

## 7. Transforma√ß√£o do Eixo M√©dio (MAT)

### Conceito:
O esqueleto pode ser definido usando a **Transforma√ß√£o do Eixo M√©dio (Medial Axis Transform ‚Äì MAT)**, baseada na ideia de encontrar pontos no interior da regi√£o que possuem **mais de um vizinho mais pr√≥ximo na borda**.

### Como funciona:
Para cada ponto interno:
- Calcula-se a dist√¢ncia at√© a borda mais pr√≥xima.
- Se existirem m√∫ltiplos pontos na borda √† mesma dist√¢ncia m√≠nima, o ponto pertence ao esqueleto.

---

## 8. Algoritmos de Esqueletoniza√ß√£o

Existem diferentes m√©todos computacionais para obter o esqueleto de uma regi√£o:

### a) Esqueletoniza√ß√£o (Skeletonization)
- Reduz a regi√£o a uma linha central fina.
- Preserva a conectividade e a forma.

### b) Afinamento (Thinning)
- Tamb√©m reduz a regi√£o a uma linha fina, mas n√£o garante o centro exato da figura.
- Mais r√°pido, mas menos preciso que a esqueletoniza√ß√£o.

### Implementa√ß√£o no MATLAB/Octave:
```matlab
BW2 = bwmorph(imagem_bin√°ria, 'skel', Inf); % Esqueletoniza√ß√£o
BW2 = bwmorph(imagem_bin√°ria, 'thin', Inf); % Afinamento
```

---

## 9. Compara√ß√£o: Esqueletoniza√ß√£o X Afinamento

| Crit√©rio | Esqueletoniza√ß√£o | Afinamento |
|--------|------------------|------------|
| Precis√£o | Alta ‚Äì encontra o centro exato | Menor ‚Äì aproxima√ß√£o simples |
| Complexidade | Maior | Menor |
| Uso t√≠pico | An√°lise precisa de formas | Aplica√ß√µes r√°pidas e simples |
| Resultado visual | Linha central bem definida | Estrutura mais irregular |

---

## 10. Exemplos Pr√°ticos

Foram mostrados exemplos de aplica√ß√£o dessas t√©cnicas em imagens como:

- **Imagens de n√∫meros bin√°rios**
- **Imagens de m√£os**
- **Imagens de folhas ou formas complexas**

Esses exemplos ilustraram como os descritores ajudam a extrair informa√ß√µes √∫teis sobre as formas presentes nas imagens.

---

## 11. Considera√ß√µes Finais

Os descritores escalares estudados nesta aula ‚Äî **n√∫mero de Euler, excentricidade, compacidade e esqueletoniza√ß√£o** ‚Äî s√£o ferramentas poderosas para descrever e comparar formas em imagens digitais. Combinados com t√©cnicas de morfologia matem√°tica, eles formam a base para an√°lise de padr√µes, reconhecimento de objetos e extra√ß√£o de caracter√≠sticas em sistemas de vis√£o artificial.
